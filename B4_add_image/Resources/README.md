## Exploitation process

1. Click `ADD IMAGE` on the main page to navigate to the upload page (ex: `http://<ip>/index.php?page=upload`).

2. Open the browserâ€™s Developer Tools by pressing `F12`. Go to `Network` to see requests. 

3. Upload a valid image file. The application allows at least `.jpeg` files.

4. In the `Network` tab, locate the `POST` request generated by the upload action. Right-click the request and select `Use as Fetch in Console`.

5. Modify the generated fetch request by changing the filename parameter to an arbitrary value (ex: `fox.fox`, `2`, `fake_file.txt`, `my_evil_script.php`).

Example snippet showing an original filename before manipulation:
```
... 
"body": "------geckoformboundary5729c51878379190f5e9b5c0f52bc2e8\r\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n100000\r\n------geckoformboundary5729c51878379190f5e9b5c0f52bc2e8\r\nContent-Disposition: form-data; name=\"uploaded\"; filename=\"correct.jpeg\"\r\nContent-Type: image/jpeg\r\n\ 
...
```

6. Send the modified fetch request. Review the server response to find the flag.

## Definitions

The application performs file validation exclusively on the client side. If the uploaded file passes the client-side checks, the request is sent with `Content-Type: image/jpeg`.

On the server side, no additional validation or sanitization is performed. The server blindly trusts the `Content-Type` header and accepts the file as-is. As a result, an attacker can intercept and modify the request to upload arbitrary files while retaining the `image/jpeg` content type.

## How to Fix

Do not rely on client-side validation alone.

1. Implement strict server-side file validation:
	* Verifying file extensions.
	* Inspecting file signatures (magic bytes) instead of trusting Content-Type.
2. Rename uploaded files on the server rather than trusting user-supplied filenames.
3. Enforce proper file permissions to ensure uploaded files cannot be executed.
